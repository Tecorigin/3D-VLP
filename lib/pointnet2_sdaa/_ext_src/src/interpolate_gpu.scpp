// Copyright (c) Facebook, Inc. and its affiliates.
// 
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sdaa_atomic.h>

#include "sdaa_utils.h"

#define TOTAL_THREADS 512

inline int opt_n_threads(int work_size) {
  const int pow_2 = std::log(static_cast<double>(work_size)) / std::log(2.0);

  return std::max(std::min(1 << pow_2, TOTAL_THREADS), 1);
}

inline dim3 opt_block_config(int x, int y) {
  const int x_threads = opt_n_threads(x);
  const int y_threads =
      std::max(std::min(opt_n_threads(y), TOTAL_THREADS / x_threads), 1);
  dim3 block_config(x_threads, y_threads, 1);

  return block_config;
}

__device__ inline float atomic_add(float *address, float val) {
    float old;
    bool is_ok = true;
    do {
        old = *address;
        float new_value = old + val;
        is_ok = __builtin_sw_slave_cas_32((int32_t *)address, *(int32_t *)&old,
                                          *(int32_t *)&new_value);
    } while (!is_ok);
    return old;
}

// input: unknown(b, n, 3) known(b, m, 3)
// output: dist2(b, n, 3), idx(b, n, 3)
__global__ void three_nn_kernel(dim3 sdaaGridDim, dim3 sdaaBlockDim,int b, int n, int m,
                                const float *__restrict__ unknown,
                                const float *__restrict__ known,
                                float *__restrict__ dist2,
                                int *__restrict__ idx) {
    int linearblockDim = sdaaGridDim.z * sdaaGridDim.y * sdaaGridDim.x;
    // threadIdx 是从核号

    for (int linearblockIdx = threadIdx; linearblockIdx < linearblockDim; linearblockIdx += 32) {
    // z = i / (DimX * DimY);
    // int remainder = i % (DimX * DimY);
    // y = remainder / DimX;
    // x = remainder % DimX;

    int blockIdx_z = linearblockIdx / (sdaaGridDim.x * sdaaGridDim.y);    // 计算z坐标
    int remainder = linearblockIdx % (sdaaGridDim.x * sdaaGridDim.y);     // 剩余部分用于计算y和x
    int blockIdx_y = remainder / sdaaGridDim.x;                           // 计算y坐标
    int blockIdx_x = remainder % sdaaGridDim.x;                           // 计算x坐标

    //   for (int blockIdx_z = 0; blockIdx_z < sdaaGridDim.z; blockIdx_z ++) {
    //     for (int blockIdx_y = 0; blockIdx_y < sdaaGridDim.y; blockIdx_y ++) {
    //       for (int blockIdx_x = 0; blockIdx_x < sdaaGridDim.x; blockIdx_x ++) {

    for (int threadIdx_z = 0; threadIdx_z < sdaaBlockDim.z; threadIdx_z ++) {
        for (int threadIdx_y = 0; threadIdx_y < sdaaBlockDim.y; threadIdx_y ++) {
            for (int threadIdx_x = 0; threadIdx_x < sdaaBlockDim.x; threadIdx_x ++) {

  int batch_index = blockIdx_x;
  const float * unknown_2 = unknown + batch_index * n * 3;
  const float * known_2 = known + batch_index * m * 3;
  float * dist2_2 = dist2 + batch_index * n * 3;
  int * idx_2 = idx + batch_index * n * 3;

  int index = threadIdx_x;
  int stride = sdaaBlockDim.x;
  for (int j = index; j < n; j += stride) {
    float ux = unknown_2[j * 3 + 0];
    float uy = unknown_2[j * 3 + 1];
    float uz = unknown_2[j * 3 + 2];

    double best1 = 1e40, best2 = 1e40, best3 = 1e40;
    int besti1 = 0, besti2 = 0, besti3 = 0;
    for (int k = 0; k < m; ++k) {
      float x = known_2[k * 3 + 0];
      float y = known_2[k * 3 + 1];
      float z = known_2[k * 3 + 2];
      float d = (ux - x) * (ux - x) + (uy - y) * (uy - y) + (uz - z) * (uz - z);
      if (d < best1) {
        best3 = best2;
        besti3 = besti2;
        best2 = best1;
        besti2 = besti1;
        best1 = d;
        besti1 = k;
      } else if (d < best2) {
        best3 = best2;
        besti3 = besti2;
        best2 = d;
        besti2 = k;
      } else if (d < best3) {
        best3 = d;
        besti3 = k;
      }
    }
    dist2_2[j * 3 + 0] = best1;
    dist2_2[j * 3 + 1] = best2;
    dist2_2[j * 3 + 2] = best3;

    idx_2[j * 3 + 0] = besti1;
    idx_2[j * 3 + 1] = besti2;
    idx_2[j * 3 + 2] = besti3;
  }
}}}}}

void three_nn_kernel_wrapper(int b, int n, int m, const float *unknown,
                             const float *known, float *dist2, int *idx) {
  unsigned int n_threads = opt_n_threads(n);                            
  dim3 blocks(b);
  dim3 threads(n_threads);
  three_nn_kernel<<<1>>>(blocks, threads, b, n, m, unknown, known, dist2, idx);
  // cudaStream_t stream = at::cuda::getCurrentCUDAStream();
  //three_nn_kernel<<<b, opt_n_threads(n), 0, stream>>>(b, n, m, unknown, known,
  //                                                    dist2, idx);

  SDAA_CHECK_ERRORS();
}

// input: points(b, c, m), idx(b, n, 3), weight(b, n, 3)
// output: out(b, c, n)
__global__ void three_interpolate_kernel(dim3 sdaaGridDim, dim3 sdaaBlockDim,int b, int c, int m, int n,
                                         const float *__restrict__ points,
                                         const int *__restrict__ idx,
                                         const float *__restrict__ weight,
                                         float *__restrict__ out) {
    int linearblockDim = sdaaGridDim.z * sdaaGridDim.y * sdaaGridDim.x;
    // threadIdx 是从核号

    for (int linearblockIdx = threadIdx; linearblockIdx < linearblockDim; linearblockIdx += 32) {
    // z = i / (DimX * DimY);
    // int remainder = i % (DimX * DimY);
    // y = remainder / DimX;
    // x = remainder % DimX;

    int blockIdx_z = linearblockIdx / (sdaaGridDim.x * sdaaGridDim.y);    // 计算z坐标
    int remainder = linearblockIdx % (sdaaGridDim.x * sdaaGridDim.y);     // 剩余部分用于计算y和x
    int blockIdx_y = remainder / sdaaGridDim.x;                           // 计算y坐标
    int blockIdx_x = remainder % sdaaGridDim.x;                           // 计算x坐标

    //   for (int blockIdx_z = 0; blockIdx_z < sdaaGridDim.z; blockIdx_z ++) {
    //     for (int blockIdx_y = 0; blockIdx_y < sdaaGridDim.y; blockIdx_y ++) {
    //       for (int blockIdx_x = 0; blockIdx_x < sdaaGridDim.x; blockIdx_x ++) {

    for (int threadIdx_z = 0; threadIdx_z < sdaaBlockDim.z; threadIdx_z ++) {
        for (int threadIdx_y = 0; threadIdx_y < sdaaBlockDim.y; threadIdx_y ++) {
            for (int threadIdx_x = 0; threadIdx_x < sdaaBlockDim.x; threadIdx_x ++) {

  int batch_index = blockIdx_x;
  const float * points_2 = points + batch_index * m * c;
  const int * idx_2 = idx + batch_index * n * 3;
  const float * weight_2 = weight + batch_index * n * 3;

  float * out_2 = out + batch_index * n * c;

  const int index = threadIdx_y * sdaaBlockDim.x + threadIdx_x;
  const int stride = sdaaBlockDim.y * sdaaBlockDim.x;
  for (int i = index; i < c * n; i += stride) {
    const int l = i / n;
    const int j = i % n;
    float w1 = weight_2[j * 3 + 0];
    float w2 = weight_2[j * 3 + 1];
    float w3 = weight_2[j * 3 + 2];

    int i1 = idx_2[j * 3 + 0];
    int i2 = idx_2[j * 3 + 1];
    int i3 = idx_2[j * 3 + 2];

    out_2[i] = points_2[l * m + i1] * w1 + points_2[l * m + i2] * w2 +
               points_2[l * m + i3] * w3;
  }
}}}}}

void three_interpolate_kernel_wrapper(int b, int c, int m, int n,
                                      const float *points, const int *idx,
                                      const float *weight, float *out) {
  dim3 blocks(b);
  dim3 threads = opt_block_config(n, c);
  three_interpolate_kernel<<<1>>>(blocks, threads, b, c, m, n, points, idx, weight, out);

  SDAA_CHECK_ERRORS();
}

// input: grad_out(b, c, n), idx(b, n, 3), weight(b, n, 3)
// output: grad_points(b, c, m)

__global__ void three_interpolate_grad_kernel(dim3 sdaaGridDim, dim3 sdaaBlockDim,
    int b, int c, int n, int m, const float *__restrict__ grad_out,
    const int *__restrict__ idx, const float *__restrict__ weight,
    float *__restrict__ grad_points) {
    int linearblockDim = sdaaGridDim.z * sdaaGridDim.y * sdaaGridDim.x;
    // threadIdx 是从核号

    for (int linearblockIdx = threadIdx; linearblockIdx < linearblockDim; linearblockIdx += 32) {
    // z = i / (DimX * DimY);
    // int remainder = i % (DimX * DimY);
    // y = remainder / DimX;
    // x = remainder % DimX;

    int blockIdx_z = linearblockIdx / (sdaaGridDim.x * sdaaGridDim.y);    // 计算z坐标
    int remainder = linearblockIdx % (sdaaGridDim.x * sdaaGridDim.y);     // 剩余部分用于计算y和x
    int blockIdx_y = remainder / sdaaGridDim.x;                           // 计算y坐标
    int blockIdx_x = remainder % sdaaGridDim.x;                           // 计算x坐标

    //   for (int blockIdx_z = 0; blockIdx_z < sdaaGridDim.z; blockIdx_z ++) {
    //     for (int blockIdx_y = 0; blockIdx_y < sdaaGridDim.y; blockIdx_y ++) {
    //       for (int blockIdx_x = 0; blockIdx_x < sdaaGridDim.x; blockIdx_x ++) {

    for (int threadIdx_z = 0; threadIdx_z < sdaaBlockDim.z; threadIdx_z ++) {
        for (int threadIdx_y = 0; threadIdx_y < sdaaBlockDim.y; threadIdx_y ++) {
            for (int threadIdx_x = 0; threadIdx_x < sdaaBlockDim.x; threadIdx_x ++) {

  int batch_index = blockIdx_x;
  const float * grad_out_2 = grad_out + batch_index * n * c;
  const int * idx_2 = idx + batch_index * n * 3;
  const float * weight_2 = weight + batch_index * n * 3;
  float *grad_points_2 = grad_points + batch_index * m * c;

  const int index = threadIdx_y * sdaaBlockDim.x + threadIdx_x;
  const int stride = sdaaBlockDim.y * sdaaBlockDim.x;
  for (int i = index; i < c * n; i += stride) {
    const int l = i / n;
    const int j = i % n;
    float w1 = weight_2[j * 3 + 0];
    float w2 = weight_2[j * 3 + 1];
    float w3 = weight_2[j * 3 + 2];

    int i1 = idx_2[j * 3 + 0];
    int i2 = idx_2[j * 3 + 1];
    int i3 = idx_2[j * 3 + 2];

    atomic_add(grad_points_2 + l * m + i1, grad_out_2[i] * w1);
    atomic_add(grad_points_2 + l * m + i2, grad_out_2[i] * w2);
    atomic_add(grad_points_2 + l * m + i3, grad_out_2[i] * w3);
  }
}}}}}

void three_interpolate_grad_kernel_wrapper(int b, int c, int n, int m,
                                           const float *grad_out,
                                           const int *idx, const float *weight,
                                           float *grad_points) {
  // cudaStream_t stream = at::cuda::getCurrentCUDAStream();
  dim3 blocks(b);
  dim3 threads = opt_block_config(n, c);
  three_interpolate_grad_kernel<<<1>>>(blocks, threads, b, c, n, m, grad_out, idx, weight, grad_points);
  // three_interpolate_grad_kernel<<<b, opt_block_config(n, c), 0, stream>>>(
  //    b, c, n, m, grad_out, idx, weight, grad_points);
  SDAA_CHECK_ERRORS();
}
