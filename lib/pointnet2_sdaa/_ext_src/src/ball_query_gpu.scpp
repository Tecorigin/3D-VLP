// Copyright (c) Facebook, Inc. and its affiliates.
// 
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "sdaa_utils.h"

#define TOTAL_THREADS 512

inline int opt_n_threads(int work_size) {
  const int pow_2 = std::log(static_cast<double>(work_size)) / std::log(2.0);

  return std::max(std::min(1 << pow_2, TOTAL_THREADS), 1);
}

// input: new_xyz(b, m, 3) xyz(b, n, 3)
// output: idx(b, m, nsample)
__global__ void query_ball_point_kernel(dim3 gridDim, dim3 blockDim,int b_orig, int n_orig, 
                                        int m_orig, float radius_orig,int nsample_orig,
                                        const float * new_xyz_orig,const float * xyz_orig, int * idx_orig) {
int linearblockDim = gridDim.z * gridDim.y * gridDim.x;
for (int linearblockIdx = threadIdx; linearblockIdx < linearblockDim; linearblockIdx += 32) {
	int blockIdx_z = linearblockIdx / (gridDim.x * gridDim.y);
	int remainder = linearblockIdx % (gridDim.x * gridDim.y);
	int blockIdx_y = remainder / gridDim.x;
	int blockIdx_x = remainder % gridDim.x;
	for (int threadIdx_z = 0; threadIdx_z < blockDim.z; threadIdx_z ++) {
		for (int threadIdx_y = 0; threadIdx_y < blockDim.y; threadIdx_y ++) {
			for (int threadIdx_x = 0; threadIdx_x < blockDim.x; threadIdx_x ++) {
        int b = b_orig;
        int n = n_orig;
        int m = m_orig;
        float radius = radius_orig;
        int nsample = nsample_orig;
        const float *__restrict new_xyz = new_xyz_orig;
        const float *__restrict xyz = xyz_orig;
        int *__restrict idx = idx_orig;
          int batch_index = blockIdx_x;
          xyz += batch_index * n * 3;
          new_xyz += batch_index * m * 3;
          idx += m * nsample * batch_index;

          int index = threadIdx_x;
          int stride = blockDim.x;

          float radius2 = radius * radius;
          for (int j = index; j < m; j += stride) {
            // m * 3
            float new_x = new_xyz[j * 3 + 0];
            float new_y = new_xyz[j * 3 + 1];
            float new_z = new_xyz[j * 3 + 2];
            for (int k = 0, cnt = 0; k < n && cnt < nsample; ++k) {
              // n * 3
              float x = xyz[k * 3 + 0];
              float y = xyz[k * 3 + 1];
              float z = xyz[k * 3 + 2];
              float d2 = (new_x - x) * (new_x - x) + (new_y - y) * (new_y - y) +
                        (new_z - z) * (new_z - z);
              if (d2 < radius2) {
                if (cnt == 0) {
                  for (int l = 0; l < nsample; ++l) {
                    // m * nsample
                    idx[j * nsample + l] = k;
                  }
                }
                idx[j * nsample + cnt] = k;
                ++cnt;
              }
            }
          }
        }
      }
    }
  }
}

void query_ball_point_kernel_wrapper(int b, int n, int m, float radius,
                                     int nsample, const float *new_xyz,
                                     const float *xyz, int *idx) {
  // cudaStream_t stream = at::cuda::getCurrentCUDAStream();
  //  Launch kernel

  // printf("Wrapper called with b=%d, n=%d, m=%d, radius=%f, nsample=%d\n", b, n, m, radius, nsample);
  // printf("new_xyz pointer: %p, xyz pointer: %p, idx pointer: %p\n", 
  //       new_xyz, xyz, idx);

  unsigned int n_threads = opt_n_threads(m);
  // printf("Using %u threads\n", n_threads);

  dim3 blocks(b);
  dim3 threads(n_threads); // Number of threads per block
  query_ball_point_kernel<<<1>>>(blocks, threads, b, n, m, radius, nsample,
                                 new_xyz, xyz, idx);

  SDAA_CHECK_ERRORS();
}
